* Stacker
  :PROPERTIES:
  :CUSTOM_ID: stacker
  :END:

A library designed to implement a stack based concatenated language
in the style of Factor, including an execution engine and a RE(P)L which easily
can be enabled for own programs with domain specific functionality.

Why? *Finally a language whose syntax I can remember!*

** Usage
   :PROPERTIES:
   :CUSTOM_ID: usage
   :END:

Either run this project on its own (see below, "Simple repl") or include
in your own =project.clj=:

    [net.nogui/stacker "0.1.1"]

*** The language

Stacker is a stack-based language, inspired by Forth, Factor and others.
You might wonder why on earth you would prefer this to a real Clojure REPL?
This is simply because I think that an interactive interface on the command line
is even easier to handle with a stack based language than the fullblown REPL in S-expressions.

Technically it is not less powerfull.

Compare a simple mathematical equation:

    (4 + 5 + 6) * (7 - 2)

in Lisp this would be

    (* (+ 4 5 6) (- 7 2))

In Stacker is is short and elegant:

    4 5 6 + + 7 2 - * p

Look Ma, no parentheses! (The final =p= is strictly not necessary, it depends on what you
want to do with the result.) When you regard the interactive aspect it becomes even more
interesting. Assume you wanted to see the interim values (or you want to build up the
result in steps), you can write:

    4 5 6 + + p 7 2 - p *

or build up the result in steps

    4 5 6 + + p
    7 2 - p
    * p

The =p= will print the top of the stack. If this was a program it would not matter much,
but for interactive instructing a program what to do this is refreshingly intuitive!

*** The syntax

    Items are normally separated by space characters (currently newline works
    only outside strings and quotations). Input will manipulate the stack (and
    the invisible environment, more about that later).

    - Numbers: =4=, =5.2=, =3.1415926=, etc
    - Strings: ="Hello, world"=, ="Hi"=
    - Words (commands): =p=, =*=, =/=, =dup=, =drop=, ...
    - Keywords: =:myvar=, =:hi-there=, ...
    - Quotations: =[ 4 5 *]=, =[ * ]=, ...
    - Lisp: =(+ 4 5 7)= (s-expressions are evaluated)

    Everything is applied to the stack. Numbers and Strings are pushed on top of the stack.
    Words can affect the stack. Quotations are not executed immediately, but pushed on the
    stack as a single object (they can be executed then using the =apply= word.

    NOTE: Pushing an *unknown* word leaves the word as a string on on the stack.
    The alternative is to always use quotes ("....."), which always renders as a string.
    This is very much a convenience feature, which will help you more often than it
    bites you. (You can switch this off by this: =1 :-strict set=)


    You can load a file containing stacker input using the =load= word. For example:

    > test1.stkr load

**** Word documentation
     > "range" doc
     ... bla bla ...

**** Self-testing
     If the word definition contains one or several tests, then the tests can be executed:

     #+begin_src stacker
     > "range" test
     ... bla bla ...
     #+end_src

     Using stacker you can easily test all defined words in one go:

     > env [test] map do

**** New words
     You can store quotations in the environment, they can then be called as any other word:

     #+begin_src stacker
       > [3 *] "tripple" set
       > 19 tripple p
       57
     #+end_src

*** The built-in functions
    For a complete list of currently defined functions you can execute =env .=.
    To get a description of a specific word you can do for example this: ="reduce" doc=.

    - . :: pops and prints the top of the stack
    - p :: prints the top of the stack
    - load :: takes a filename as a single parameter. Loads, parses and applies the file to the stack.
    - drop :: drops the top of the stack
    - dup :: duplicates the top of the stack
    - *,/,+,- :: takes the top two elements of the stack, multiplies (divides, etc) them and puts the result back on the stack.
    - swap :: swaps the top two elements on the stack
    - set :: stores the second element on the stack in the enviroment using what is on top as the index.
    - get :: retrieves what is indicated by the top from the env.
    - apply :: pops the top of the stack (it must be a quotation) and appies it to the current stack.

*** Simple repl
    :PROPERTIES:
    :CUSTOM_ID: simple-repl
    :END:

    Run =lein run= or =java -jar stacker.jar net.nogui.stacker= to start a repl session.
    Technically it is not a "REPL", rather a "REL" (no automatic (P)rint) or a "shell", whatever you prefer.

    Run with parameters (one or many) to start repl and process the commands
    from the parameter.

    Example:

    #+BEGIN_EXAMPLE
        lein run "4 5 * p q"
        => prints "20"
    #+END_EXAMPLE

    or

    #+BEGIN_EXAMPLE
        lein run "4 5 *" p 355 113. "/" p q
    #+END_EXAMPLE

    The quotation marks are only necessary because of the shell,
    which would otherwise expand the =*= for example. The programm
    will currently feed all parameters (=argv=) to the parser and evaluate
    everything in order.

    The "q" is necessary to end the repl / the programm. If you leave that
    out, the repl/shell continues after processing the initial input.

*** Your own programs
    :PROPERTIES:
    :CUSTOM_ID: your-own-programs
    :END:

    include it into your =project.clj=

    [[https://clojars.org/net.nogui/stacker][[https://img.shields.io/clojars/v/net.nogui/stacker.svg]]]


    You can now extend the environment with your own commands and thus give your
    own tools a convenient REPL:)

    1 TBD: extend the @default-env with your own functions (probably)
2) start with a (probably) empty stack, a simple empty list =()= in almost all cases.
3) Repeat until tired: Apply tokens on the [stack env] pair. You can use
   =string-to-tokens= to convert a string to a list of tokens.
4) Alternatively you can call the provided =repl= on the start-stack and
   env, which starts an interactive repl for you.

** License
   :PROPERTIES:
   :CUSTOM_ID: license
   :END:

Copyright © 2017-2018 Jörg Ramb

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
